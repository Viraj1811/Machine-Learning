# -*- coding: utf-8 -*-
"""KNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Yzeq3EW3ZO7q_IJICK3vGb1npCwKHOq9
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import math

url = "https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"

# Assign colum names to the dataset
names = ['sepal-length', 'sepal-width', 'petal-length', 'petal-width', 'Class']

# Read dataset to pandas dataframe
dataset = pd.read_csv(url, names=names)

dataset.head()

dataset

num_neighbors = 5

training=dataset.values[0:148,0:4]
training

def str_column_to_float(dataset, column):
	for row in dataset:
		row[column] = float(row[column])

for i in range(len(training[0])):
  str_column_to_float(training,i)

training

trainingclass=dataset.values[0:148,-1]
trainingclass

def euclidean_distance(row1, row2):
	distance = 0.0
	for i in range(len(row1)-1):
		distance += (row1[i] - row2[i])**2
	return (math.sqrt(distance))

testing=dataset.values[148,0:4]
testing

unique_list=[]
for x in trainingclass:
  if x not in unique_list:
    unique_list.append(x)

print(unique_list)
for i in range(len(trainingclass)):
  for k in range(len(unique_list)):
    if(trainingclass[i]==unique_list[k]):
      trainingclass[i]=k
print(trainingclass)

distance=[]
for i in range(len(training)):
  distance.append([euclidean_distance((training[i]),(testing)),trainingclass[i]])

distance

distance.sort()
distance

identify=[0 for i in range(len(unique_list))]
for i in range(num_neighbors):
  identify[distance[i][1]]=identify[distance[i][1]]+1

identify

print("The predicted class is: ",unique_list[identify.index(max(identify))])

#Your task is to randomize the same data set with some seed value and separate it into two datasets as training and testing datasets
#compute the predicted class for all the testing data set and generate the confusion matrix and determine the accuracy

# Function to get the k nearest neighbors
def get_neighbors(train_X, train_y, test_row, num_neighbors):
    distances = []
    for i in range(len(train_X)):
        dist = euclidean_distance(test_row, train_X[i])
        distances.append((dist, train_y[i]))
    distances.sort(key=lambda x: x[0])
    neighbors = [distances[i][1] for i in range(num_neighbors)]
    return neighbors

# Function to predict the class for a test row
def predict_classification(train_X, train_y, test_row, num_neighbors):
    neighbors = get_neighbors(train_X, train_y, test_row, num_neighbors)
    output_values = neighbors
    prediction = max(set(output_values), key=output_values.count)
    return prediction

# Predict the class for all testing data
predictions = []
for row in X_test:
    predictions.append(predict_classification(X_train, y_train_encoded, row, num_neighbors))

display(predictions)

from sklearn.metrics import confusion_matrix, accuracy_score

# Generate the confusion matrix
cm = confusion_matrix(y_test_encoded, predictions)
print("Confusion Matrix:")
display(cm)

# Determine the accuracy
accuracy = accuracy_score(y_test_encoded, predictions)
print("Accuracy:", accuracy)